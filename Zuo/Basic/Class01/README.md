## Basic Class01


### 时间复杂度O(*)
  时间复杂度：设数据量为N,，完整执行某一个算法流程时，在其最差的情况中，所用时间与与常数操作O(1)的关系
  用一个表达式来表示这种关系，其中用N的最高阶来表示时间复杂度）
  常用的时间复杂度为, 由好到差分别为：
      O(1), O(logN), O(N), O(N*logN),
      O(N^2), O(N^3), ..., O(N^k),
      O(2^N), O(3^N), O(k^N),
      O(N!)

常数时间O(1)的操作：常数操作是固定时间的操作
  常见的算数运算+ - * / %
  常见的位运算： >>, <<, >>>, |, &, ^
  赋值、比较、自增、自减操作等
  数组寻址：数组在内存中是一个连续结构的数据结构，即使有有限跳转，其寻址的时间也是常数操作
非固定时间的操作
  链表（跳转结构）的寻址，操作时间受链表长度的影响，不是常数时间的操作
总之，执行时间固定的和数据量无关的操作都是常数时间的操作；反之，执行时间不固定和数据量有关的操作 ，都不是常数操作


### 评估算法优劣的重要指标是什么：
  时间复杂度：确定算法流程的总操作数与样本量之间的表达式，只看表达式最高阶的部分
  额外空间复杂度：用户给到的，不属于额外空间 (和输入输出无关的自主空间，为额外空间复杂度)
      eg1. 如果只有有限几个变量，额外空间复杂度是O(1)
      eg2. 如果如果开辟了一个元素count的map, 其最差的情况是每一个元素都不一样，那么map的额外空间复杂度是O(N)
      eg3. 要求实现的功能是copy一个新数组，额外空间复杂度是O(1), 因为在流程中只使用了有限几个变量，虽然最终输出的是长度为N的数组，但是这个输出是用户要求的功能，
      不属于为了实现这个功能而额外开辟的空间，所以额外空间复杂度是O(N)
  算法流程的常数时间（思考，如果两个时间复杂度相同的算法，哪个更好，就要用到算法流程的常数时间）
      eg1. 冒泡排序 vs 插入排序，插入排序的常数时间好
      如何比较算法流程的常数时间，放弃理论分析，直接用大样本测试，速度快的算法流程的常数时间好
      比如算数运算中，比较谁的速度快， 直接上大样本运行测试


Note
   算法的过程，和具体的语言无关
   想分析一个算法流程的时间复杂度的前提是，对流程非常数据
   一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作，这意味着，你写算法时，对自己用过的每一个系统api，都非常熟悉，否则会影响你对时间复杂度的估计


### 刷题、面试中，算法的最优解：
  1. 首先满足时间复杂度尽可能低
  2. 在最优时间复杂度的基础上，尽可能优化额外空间复杂度
  算法的最优解不包括常数时间的情况


### 算法和数据结构的大脉络：
  1. 知道怎么算的算法
  2. 知道怎么试的算法
  所有的题目的讲解，对于大脉络的时间贯穿始终
  图灵之后，才有了知道怎么试的算法
  
  
### 选择排序O(N^2)
  0～N-1：找到最小放到0位置上
  1～N-1：找到最小放到1位置上
  2～N-1：找到最小放到2位置上
  ...


### 冒泡排序(O(N^2)
0～1：大值右移
1～2：大值右移
...
n-2~n-1：大值右移
0~1:：大值右移
...
n-3~n-2：大值右移


### 插入排序
时间复杂度（N*N) = O(N^2)
0～0有序：0有序
0～1有序：0-1有序
0～2有序：1-2有序，0-1有序
0～3有序：2-3有序，1-2有序， 0-1有序
...
0～n-1有序：(n-2)-(n-1)有序, ..., 0-1有序

Note: 流程的状况会随数据的状况而变化，因此流程的时间复杂度是流程随数据情况变化的最差情况，这里插入排序的最好情况是O(N), 最差情况O(N^2)


### 对数器
写好了算法过程，找不到测试用例，大样本出错，你好心烦。。。这个时候可用对数器
同样一个功能，可以用多种方式去实现，差的办法总能写出来的，我们往往想测的是自认为相当好的办法的正确与否
有两个方法A，B，不考虑谁更优，是两套思路下的办法，如果随机产生了数据很多大样本，如果两个方法的结果是一样的，就可以说明大概率下，两个方法都是对的，这个想法有点绝，符合概率论的观点。
生成随机样本，测试两个方法结果是否一直。可以不依赖别人提供的测试用例， 竞赛的朋友们都是用这个方法来联系code的


### 二分法
最经典的使用二分法解决的问题，在一个有序数组中找某个数存在与否
  如果用遍历的方法来处理，时间复杂度是O(N)
  更好的办法，使用二分法 O(logN), 一次砍一半，一次砍一半。。。

有序不是所有问题使用二分法的必要条件， 只要能正确构建左右两侧的淘汰逻辑，就可以使用二分法

体会以下可以使用二分法的例子
  eg1. 在有序数组中，判断某个数是否存在
  eg2. 在有序数组中，找到>=某个数最左的位置
  eg3. 在有序数组中，找到<=某个数最右的位置
  eg4. 局部最小值问题


